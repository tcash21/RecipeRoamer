{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(tm)\nlibrary(DT)\nlibrary(networkD3)\nlibrary(shiny)\nlibrary(stringi)\nlibrary(igraph)\nlibrary(stringr)\nlibrary(shinyBS)\nlibrary(shinyjs)\nlibrary(scales)\n\ngoogle_img_head <- 'https://www.google.com/search?q='\ngoogle_img_tail <- '&safe=off&source=lnms&tbm=isch'\n\n## flatten out the ingredients list for performance/search reasons\nflat_ingredients <-lapply(r$ingredients, function(x) paste(x, collapse=\" \"))\n\n## Set color scale, needs to be tweaked\ngroup <- data.frame(rating = c('Perfect', 'Best', 'Above Average', 'Average', 'Below Average', 'Worst', 'Inedible'), value= c(5, 4, 3.8,3.6, 3, 2, 0))\ngroup <- group[order(group$value),]\n\n## Lots of these values are missing, set to 0 so we don't lose the recipes\nr$calories[which(is.na(r$calories))] <- 0\nr$sodium[which(is.na(r$sodium))] <- 0\nr$fat[which(is.na(r$fat))] <- 0\n\nshinyServer(function(input, output) {\n\n  df <- reactiveValues()\n  ingredients_clicked <- reactiveValues()\n  fridge_ingredients <- reactiveValues()\n  the_recipes <- reactiveValues()\n  counter <- reactiveValues(n = 0)\n  \n  observeEvent(input$add_btn, {\n    counter$n <- counter$n + 1\n    if(counter$n > 1){\n      fridge_ingredients$ingredients[counter$n] <- eval(parse(text=paste0('input$textin', counter$n)))\n    }\n  })\n  \n  textboxes <- reactive({\n    n <- counter$n\n    if(n == 1){\n      fridge_ingredients$ingredients[n] <- input$ingredient1\n      lapply(seq_len(n), function(i) {\n        textInput(inputId = paste0(\"textin\", i+1),\n                  label = paste0(\"Ingredient\", i+1),\n                  value = '')})\n      } else if (n > 1){\n        lapply(seq_len(n), function(i) {\n          textInput(inputId = paste0(\"textin\", i+1),\n                    label = paste0(\"Ingredient\", i+1),\n                    value = fridge_ingredients$ingredients[-1][i])})\n      }\n   })\n  \n  output$textbox_ui <- renderUI({ textboxes() })\n  \n  output$recipes2 <- DT::renderDataTable({\n    if(input$ingredient1 == '' | input$add_btn == 0){\n      return()\n    }\n    m <- sapply(fridge_ingredients$ingredients, function(x) stri_detect_regex(flat_ingredients, x))\n    i <- apply(m, 1, all)\n    the_recipes_df2 <- r[i,]\n    the_recipes_df2$id <- 1:nrow(the_recipes_df2)\n    the_recipes_df2 <<- the_recipes_df2\n    df<-data.frame(Title=the_recipes_df2$title, Rating = the_recipes_df2$rating, Calories = the_recipes_df2$calories,\n                   Fat = the_recipes_df2$fat, Sodium = the_recipes_df2$sodium,\n                   recipe = paste0(\"<button id='button_\", the_recipes_df2$id, \"' type=\\'button\\' class=\\'btn btn-default action-button\\' onclick=\\'Shiny.onInputChange(&quot;select_button2&quot;, this.id)\\'>View Recipe</button>\"))\n    #df <- df[order(df$Rating, decreasing=TRUE),]\n    df\n    \n  }, server = TRUE, rownames=FALSE, escape = FALSE, selection = 'single', options = list(order = list(list(2, 'desc')))\n  )\n  \n  observeEvent(input$select_button2, {\n    selectedRow <- as.numeric(strsplit(input$select_button2, \"_\")[[1]][2])\n    the_selected_recipe <- the_recipes_df2[selectedRow,]\n    ing <- unlist(the_selected_recipe$ingredients)\n    directions <- unlist(the_selected_recipe$directions)\n    the_header <- \"<h3>Ingredients</h3><ul><li>\"\n    \n    showModal(modalDialog(\n      title = the_selected_recipe$title,\n      HTML(paste0(the_header, paste0(ing, collapse='<li>'), '</ul><h3>Directions</h3><ul><li>', paste0(directions, collapse=\"<li>\"), \"</ul>\"))\n    ))\n    \n  })\n  \n  observeEvent(input$reset2, {\n    fridge_ingredients$ingredients <- NULL\n    the_recipes$recipes <- NULL\n    df$the_df <- NULL\n    counter$n <- 0\n    reset('ingredient1')\n    \n  })\n  \n  \n  output$About <- renderText(HTML(\"<br>Data Source: <a href = 'http://www.epicurious.com/', target='_blank'>epicurious</a>\"))\n    \n  shinyInput <- function(FUN, len, id, ...) {\n    inputs <- character(len)\n    inputs <- sapply(1:length(inputs), function(i) as.character(FUN(paste0(id, i), ...)))\n    inputs\n  }\n  \n  output$ingredients <- renderUI({\n    if(input$go == 0){\n      return()\n    }\n    the_string <- paste0(\"<br><br>You are viewing recipes consisting of: <ul><li>\", ingredients_clicked$ingredients[1], \"</li>\")\n    if(length(ingredients_clicked$ingredients) >= 2){\n      for(i in 2:length(ingredients_clicked$ingredients)){\n        the_string <- paste0(the_string, \"<li>\", ingredients_clicked$ingredients[i], \"</li>\")\n      }\n    }\n    HTML(the_string)\n  })\n\n  observeEvent(input$reset, {\n    ingredients_clicked$ingredients <- NULL\n    the_recipes$recipes <- NULL\n    df$the_df <- NULL\n    reset('ingredient')\n  })\n  \n  observeEvent(input$select_button, {\n    selectedRow <- as.numeric(strsplit(input$select_button, \"_\")[[1]][2])\n    the_selected_recipe <- the_recipes_df[selectedRow,]\n    ing <- unlist(the_selected_recipe$ingredients)\n    directions <- unlist(the_selected_recipe$directions)\n    the_header <- \"<h3>Ingredients</h3><ul><li>\"\n    \n    showModal(modalDialog(\n      title = the_selected_recipe$title,\n      HTML(paste0(the_header, paste0(ing, collapse='<li>'), '</ul><h3>Directions</h3><ul><li>', paste0(directions, collapse=\"<li>\"), \"</ul>\"))\n    ))\n    \n    })\n  \n  observeEvent(input$go, {\n    hide(id = \"instructions\", anim = TRUE)\n    validate(\n      need(input$ingredient != \"\", \"Please type an ingredient.\")\n    )\n    if(input$go > 1){\n      ingredients_clicked$ingredients <- NULL\n      the_recipes$recipes <- NULL\n      df$the_df <- NULL\n    }\n    the_ingredients <- getAssociatedIngredients(input$ingredient)\n    ingredients_clicked$ingredients <- c(ingredients_clicked$ingredients, input$ingredient)\n    the_ingredients_p <- paste0(c(as.character(input$ingredient), as.character(the_ingredients$ingredients)), \".*\")\n    m <- sapply(the_ingredients_p, function(x) stri_detect_regex(flat_ingredients, x))\n    i_ratings <- apply(m, 2, function(x) mean(r[x,]$rating, na.rm=TRUE))\n    \n    df$the_df <- data.frame(c(as.character(input$ingredient), as.character(the_ingredients$ingredients)), avg_rating=i_ratings, cor=c(1,the_ingredients$cors))\n    df$the_df$src <- isolate(input$ingredient)\n    colnames(df$the_df)[1] <- 'target'\n    unique(df$the_df[,c('target', 'avg_rating')])\n    if(any(duplicated(df$the_df$target))){\n      df$the_df <- df$the_df[-which(duplicated(df$the_df$target)),]  \n    }\n    if(any(is.nan(df$the_df$avg_rating))){\n      df$the_df <- df$the_df[-which(is.nan(df$the_df$avg_rating)),]  \n    }\n  })\n  \n  observeEvent(input$node, {\n    if(is.null(input$node)){\n      return()\n    }\n    \n    clicked_node <- input$node\n    ingredient <- strsplit(clicked_node, \":\")[[1]][1]\n    ingredients_clicked$ingredients <- c(ingredients_clicked$ingredients, ingredient)\n    the_ingredients <- getAssociatedIngredients(ingredient)\n    \n    the_ingredients_p <- paste0(the_ingredients$ingredients, \".*\")\n    m <- sapply(the_ingredients_p, function(x) stri_detect_regex(flat_ingredients, x))\n    i_ratings <- apply(m, 2, function(x) mean(r[x,]$rating, na.rm=TRUE))\n    \n    adf <- data.frame(the_ingredients$ingredients, avg_rating=i_ratings, cor=the_ingredients$cors)\n    adf$src <- ingredient\n    colnames(adf)[1] <- 'target'\n    df$the_df <- isolate(rbind(df$the_df, data.frame(target=ingredient, cor=1, avg_rating=mean(adf$avg_rating), src=ingredient), adf))\n    if(any(duplicated(df$the_df$target))){\n      df$the_df <- df$the_df[-which(duplicated(df$the_df$target)),]  \n    }\n    if(any(is.nan(df$the_df$avg_rating))){\n      df$the_df <- df$the_df[-which(is.nan(df$the_df$avg_rating)),]  \n    }\n\n  })\n\n  ## get associated ingredients\n  getAssociatedIngredients <- function(ingredient){\n    f<-findAssocs(dtms, ingredient, corlimit=0) \n    words <- names(f[[1]])[1:10]\n    cors <- f[[1]][1:10]\n    return(data.frame(ingredients=c(words), cors = c(cors)))\n  }\n  \n\n  output$force <- renderForceNetwork({\n    if(input$go == 0 | is.null(df$the_df)){\n      return()\n    }\n    \n    g <- graph.data.frame(df$the_df[c('src', 'target')], directed=F)\n    V(g)$name<-1:length(V(g)$name)\n    links<-as.data.frame(get.edgelist(g)) #set name to number so calculate link correctly\n    links$V1<-as.numeric(links$V1)\n    links$V2<-as.numeric(links$V2)\n    colnames(links)<-c(\"source\",\"target\")\n    el <- data.frame(from=as.numeric(factor(links$source))-1, \n                     to=as.numeric(factor(links$target))-1, Value = rescale(df$the_df$cor, 0,10))\n    nl <- cbind(idn=factor(df$the_df$target, levels=unique(df$the_df$target)), df$the_df)\n    nl$group <- group[findInterval(nl$avg_rating, group$value),]$rating\n    nl$idn <- paste0(nl$idn, \":\", as.character(round(nl$avg_rating, 2)))\n    nl$nodesize <- rescale(nl$avg_rating, to=c(1,40))\n    forceNetwork(Links = el, Nodes = nl,Source = \"from\", Target = \"to\", NodeID = \"idn\",Group = \"group\", opacity=0.9,\n                 colourScale = \"d3.scale.category10()\", charge=-320, linkDistance = 200, zoom=TRUE, width=800, height=1000, \n                 legend = TRUE, fontSize = 18, opacityNoHover = 0.6, clickAction='myclick(d)', Nodesize='nodesize')\n  })\n  \n  output$recipes <- DT::renderDataTable({\n    if(input$go == 0 | is.null(ingredients_clicked$ingredients)){\n      return()\n    }\n    m <- sapply(ingredients_clicked$ingredients, function(x) stri_detect_regex(flat_ingredients, x))\n    i <- apply(m, 1, all)\n    the_recipes_df <- r[i,]\n    the_recipes_df <- the_recipes_df[which(the_recipes_df$calories <= input$calories & \n                                    the_recipes_df$sodium <= input$sodium &\n                                    the_recipes_df$fat <= input$fat),]  \n    the_recipes_df$id <- 1:nrow(the_recipes_df)\n    the_recipes_df <<- the_recipes_df\n    df<-data.frame(Title=the_recipes_df$title, Rating = the_recipes_df$rating, Calories = the_recipes_df$calories,\n                   Fat = the_recipes_df$fat, Sodium = the_recipes_df$sodium,\n                   recipe = paste0(\"<button id='button_\", the_recipes_df$id, \"' type=\\'button\\' class=\\'btn btn-default action-button\\' onclick=\\'Shiny.onInputChange(&quot;select_button&quot;, this.id)\\'>View Recipe</button>\"))\n    df\n\n  }, server = TRUE, rownames=FALSE, escape = FALSE, selection = 'single', options = list(order = list(list(2, 'desc')))\n  )\n  \n  output$about <- renderUI(\n    HTML(\"Blah\")\n  )\n\n})\n",
    "created" : 1493224139958.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2464159395",
    "id" : "A3240ED6",
    "lastKnownWriteTime" : 1493225146,
    "last_content_update" : 1493225146851,
    "path" : "~/R/RecipeRoamer/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}